package Main;

import java.lang.reflect.Field;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.lang3.builder.EqualsBuilder;

@SuppressWarnings("unused")
public class Person {
	public String name; // What is your name, friend?
	public DayOfWeek[] avalibleDays; // Weekdays that work
	public List<LocalDate> blacklistDate; // Specific dates that don't work

	// Self explanatory, hopefully
	public List<LocalDate> assignedDays; // Perhaps these should store LocalDate objects instead
	private List<LocalDate> presentDays;
	private List<LocalDate> missedDays;

	// TODO Implement later...
	private String email;
	private String note;
	private String per3;
	private String per4;

	// For optimizations
	private LocalDate prevDateQueired;
	private int prevCountReturned;

	public Person( String name, DayOfWeek[] avalibleDays, List<LocalDate> presentDays, List<LocalDate> assignedDays, List<LocalDate> missedDays, List<LocalDate> blacklistDate ) {
		this.name = name;
		this.avalibleDays = avalibleDays;
		this.presentDays = presentDays;
		this.assignedDays = assignedDays;
		this.missedDays = missedDays;
		this.blacklistDate = blacklistDate;
		
		this.prevCountReturned = 0;
		this.prevDateQueired = LocalDate.MIN; // Why not?
	}

	public Person( String name, DayOfWeek[] days ) {
		this( name, days, new ArrayList<LocalDate>(), new ArrayList<LocalDate>(), new ArrayList<LocalDate>(), new ArrayList<LocalDate>() );
	}

	public Person( String name ) {
		this( name, new DayOfWeek[] { DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY } );
	}

	public double getScore() { // TODO imprelement sqrt curve?
		return getRate();
	}

	public double getScore( LocalDate date ) {
		return getRate( date );
	}

	public double getRate() {
		if( assignedDays.size() == 0 ) { return 1; }
		return 1.0 * presentDays.size() / assignedDays.size();
	}

	public double getRate( LocalDate date ) {
		List<LocalDate> pastAssignments = new ArrayList<>();

		for( LocalDate d : assignedDays ) {
			if( d.isBefore(date) ) {
				pastAssignments.add(d);
			}
		}

		if( pastAssignments.size() == 0 ) { return 1; }
		return 1.0 * presentDays.size() / pastAssignments.size();
	}

	public void present( Day day ) {
		present( day.getDate() );
	}
	
	public void present( LocalDate date ) {
		presentDays.add( date );
	}

	public void absent( Day day ) {
		absent( day.getDate() );
	}
	
	public void absent( LocalDate date ) {
		missedDays.add( date );
	}

	public boolean avalible( DayOfWeek day ) {
		for( DayOfWeek d : avalibleDays ) {
			if( d.equals( day ) ) {
				return true;
			}
		}

		return false;
	}

	public boolean avalible( LocalDate date ) {
		if( blacklistDate.contains( date ) ) {
			return false;
		}

		return avalible( date.getDayOfWeek() );
	}

	public int futureAssignmentCount( LocalDate date ) {
		// TODO can be optimized, bc all days past the first match should also match
		if( !date.isEqual(prevDateQueired) ) {
			int count = 0;

			for( LocalDate d : assignedDays ) {
				if( d.isAfter( date ) ) {
					++count;
				}
			}

			this.prevCountReturned = count;
			this.prevDateQueired = date;

			return count;
		} else {
			return prevCountReturned;
		}
	}
	
	/* GETTERS */
	
	public List<LocalDate> getPresentDays() {
		return presentDays;
	}

	public List<LocalDate> getMissedDays() {
		return missedDays;
	}

	public String getEmail() {
		return email;
	}

	public String getNote() {
		return note;
	}

	public String getPer3() {
		return per3;
	}

	public String getPer4() {
		return per4;
	}
	
	/* OBJECT UTILS */

	@Override
	public String toString() {
		return "Person{name=" + name + "}";
	}

	@Override
	public int hashCode() {
		// Generated by eclipse
		final int prime = 31;
		int result = 1;
		result = prime * result + ((assignedDays == null) ? 0 : assignedDays.hashCode());
		result = prime * result + Arrays.hashCode(avalibleDays);
		result = prime * result + ((blacklistDate == null) ? 0 : blacklistDate.hashCode());
		result = prime * result + ((email == null) ? 0 : email.hashCode());
		result = prime * result + ((missedDays == null) ? 0 : missedDays.hashCode());
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		result = prime * result + ((note == null) ? 0 : note.hashCode());
		result = prime * result + ((per3 == null) ? 0 : per3.hashCode());
		result = prime * result + ((per4 == null) ? 0 : per4.hashCode());
		result = prime * result + ((presentDays == null) ? 0 : presentDays.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if( !( obj instanceof Person ) ) {
			return false;
		} else  if( obj == this ) {
			return true;
		}
		
		Person p = (Person) obj;
		
		return new EqualsBuilder().append(name, p.name).append(avalibleDays, p.avalibleDays)
				.append(blacklistDate, p.blacklistDate).append(assignedDays, p.assignedDays)
				.append(presentDays, p.getPresentDays()).append(missedDays, p.getMissedDays())
				.append(email, p.getEmail()).append(note, p.getNote()).append(per3, p.getPer3())
				.append(per4, p.getPer4()).isEquals();
	}

}
