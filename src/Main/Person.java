package Main;

import java.lang.reflect.Field;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.lang3.builder.EqualsBuilder;

@SuppressWarnings("unused")
public class Person {
	public String name; // What is your name, friend?
	public DayOfWeek[] avalibleDays; // Weekdays that work
	public List<LocalDate> blacklistDate; // Specific dates that don't work

	// Self explanatory, hopefully
	public List<LocalDate> assignedDays; // Perhaps these should store LocalDate objects instead
	private List<LocalDate> presentDays;
	private List<LocalDate> missedDays;

	// TODO Implement later...
	private String email;
	private String note;
	private String per3;
	private String per4;

	// For optimizations
	private LocalDate prevDateQueired;
	private int prevCountReturned;

	public Person( String name, DayOfWeek[] avalibleDays, List<LocalDate> presentDays, List<LocalDate> assignedDays, List<LocalDate> missedDays, List<LocalDate> blacklistDate ) {
		this.name = name;
		this.avalibleDays = avalibleDays;
		this.presentDays = presentDays;
		this.assignedDays = assignedDays;
		this.missedDays = missedDays;
		this.blacklistDate = blacklistDate;
		
		this.prevCountReturned = 0;
		this.prevDateQueired = LocalDate.MIN; // Why not?
	}

	public Person( String name, DayOfWeek[] days ) {
		this( name, days, new ArrayList<LocalDate>(), new ArrayList<LocalDate>(), new ArrayList<LocalDate>(), new ArrayList<LocalDate>() );
	}

	public Person( String name ) {
		this( name, new DayOfWeek[] { DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY } );
	}

	public double getScore() { // TODO imprelement sqrt curve?
		return getRate();
	}

	public double getScore( LocalDate date ) {
		return getRate( date );
	}

	public double getRate() {
		if( assignedDays.size() == 0 ) { return 1; }
		return 1.0 * presentDays.size() / assignedDays.size();
	}

	public double getRate( LocalDate date ) {
		List<LocalDate> pastAssignments = new ArrayList<>();

		for( LocalDate d : assignedDays ) {
			if( d.isBefore(date) ) {
				pastAssignments.add(d);
			}
		}

		if( pastAssignments.size() == 0 ) { return 1; }
		return 1.0 * presentDays.size() / pastAssignments.size();
	}

	public void present( Day day ) {
		present( day.getDate() );
	}
	
	public void present( LocalDate date ) {
		presentDays.add( date );
	}

	public void absent( Day day ) {
		absent( day.getDate() );
	}
	
	public void absent( LocalDate date ) {
		missedDays.add( date );
	}

	public boolean avalible( DayOfWeek day ) {
		for( DayOfWeek d : avalibleDays ) {
			if( d.equals( day ) ) {
				return true;
			}
		}

		return false;
	}

	public boolean avalible( LocalDate date ) {
		if( blacklistDate.contains( date ) ) {
			return false;
		}

		return avalible( date.getDayOfWeek() );
	}

	public int futureAssignmentCount( LocalDate date ) {
		// TODO can be optimized, bc all days past the first match should also match
		if( !date.isEqual(prevDateQueired) ) {
			int count = 0;

			for( LocalDate d : assignedDays ) {
				if( d.isAfter( date ) ) {
					++count;
				}
			}

			this.prevCountReturned = count;
			this.prevDateQueired = date;

			return count;
		} else {
			return prevCountReturned;
		}
	}
	
	/* GETTERS */
	
	public List<LocalDate> getPresentDays() {
		return presentDays;
	}

	public List<LocalDate> getMissedDays() {
		return missedDays;
	}

	public String getEmail() {
		return email;
	}

	public String getNote() {
		return note;
	}

	public String getPer3() {
		return per3;
	}

	public String getPer4() {
		return per4;
	}
	
	/* OBJECT UTILS */

	@Override
	public String toString() {
		return "Person{name=" + name + "}";
	}

	@Override
	public int hashCode() {
		// Generated by eclipse
		final int prime = 31;
		int result = 1;
		result = prime * result + ((assignedDays == null) ? 0 : assignedDays.hashCode());
		result = prime * result + Arrays.hashCode(avalibleDays);
		result = prime * result + ((blacklistDate == null) ? 0 : blacklistDate.hashCode());
		result = prime * result + ((email == null) ? 0 : email.hashCode());
		result = prime * result + ((missedDays == null) ? 0 : missedDays.hashCode());
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		result = prime * result + ((note == null) ? 0 : note.hashCode());
		result = prime * result + ((per3 == null) ? 0 : per3.hashCode());
		result = prime * result + ((per4 == null) ? 0 : per4.hashCode());
		result = prime * result + ((presentDays == null) ? 0 : presentDays.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		// Generated by eclipse
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof Person))
			return false;
		Person other = (Person) obj;
		if (assignedDays == null) {
			if (other.assignedDays != null)
				return false;
		} else if (!assignedDays.equals(other.assignedDays))
			return false;
		if (!Arrays.equals(avalibleDays, other.avalibleDays))
			return false;
		if (blacklistDate == null) {
			if (other.blacklistDate != null)
				return false;
		} else if (!blacklistDate.equals(other.blacklistDate))
			return false;
		if (email == null) {
			if (other.email != null)
				return false;
		} else if (!email.equals(other.email))
			return false;
		if (missedDays == null) {
			if (other.missedDays != null)
				return false;
		} else if (!missedDays.equals(other.missedDays))
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		if (note == null) {
			if (other.note != null)
				return false;
		} else if (!note.equals(other.note))
			return false;
		if (per3 == null) {
			if (other.per3 != null)
				return false;
		} else if (!per3.equals(other.per3))
			return false;
		if (per4 == null) {
			if (other.per4 != null)
				return false;
		} else if (!per4.equals(other.per4))
			return false;
		if (presentDays == null) {
			if (other.presentDays != null)
				return false;
		} else if (!presentDays.equals(other.presentDays))
			return false;
		return true;
		
	}

}
